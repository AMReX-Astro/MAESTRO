#!/bin/ksh -p

#----------------------------------------------------------------------------
# user modifiable variables:

# pidfile is a lock file that is used to make sure that only one instance 
# of this script is working on the current directory
pidfile=process.pid


# set the prefix of the plotfiles and checkpoint files
plt_prefix=*_plt
chk_prefix=*_chk

# directory to archive to on HPSS -- set this to the working directory
work_dir=`pwd`
HPSS_DIR=`basename $work_dir`

# set HTAR command
HTAR=/usr/local/bin/htar

# path to the ftime executable -- used for making a simple ftime.out file
# listing the name of the plotfile and its simulation time
FTIME_EXE=./ftime.Linux.Intel.exe


#----------------------------------------------------------------------------
# initialization stuff

# check to make sure that the lock file does not already exist.
if [ -f $pidfile ]; then
  echo 2>&1 "process lock file " $pidfile " already exists"
  exit -1
fi

# create the lock file
echo $$ > $pidfile

# if our process if killed, remove the lock file first
trap '/bin/rm -f $pidfile' EXIT HUP TERM XCPU KILL

# Number of seconds to sleep before checking again.
N=60



#----------------------------------------------------------------------------
# make storage directories

# once we process a file, we will move the plotfiles into the plotfiles/
# directory.  This then hides them from the script, so if the system
# later purges the files in the pltXXXXX directory and the .processed
# file, we don't overwrite our archived data with a tarred empty
# directory structure

if [ ! -d plotfiles ]; then
  mkdir plotfiles
fi


#----------------------------------------------------------------------------
# the processing function

# Process Files.  Once a plotfile is successfully processed, we will output
# a file pltXXXXX.processed (checkpoint files are only archived, with a
# chkXXXXX.processed file appearing once the archiving is successful).  
# Subsequent invocations of this routine will skip over any plotfiles or
# checkpoint files that have a corresponding .processed file.


function process_files
{
  if [ ! -f $pidfile ]; then
    echo "process: $pidfile has been removed, exiting"
    exit
  fi


  # plotfiles

  # Take all but the final plt file -- we want to ensure they're completely 
  # written to disk.  Strip out any tar files that are lying around as well 
  # as pltXXXXX.processed files.
  #pltlist=$(ls -d ${plt_prefix}* 2>/dev/null | grep -v tar | grep -v processed)
  pltlist5=$(find . -maxdepth 1 -type d -name "${plt_prefix}?????" -print | sort)
  pltlist6=$(find . -maxdepth 1 -type d -name "${plt_prefix}??????" -print | sort)

  pltlist="$pltlist5 $pltlist6"

  if [ "$pltlist" ]; then
    nl=$(echo "$pltlist" | wc -l)
    nl=$(expr $nl - 1)
    if [ $nl -eq 0 ]; then
      pltlist=""
    else
      pltlist=$(echo "$pltlist" | head -$nl)
    fi
  fi


  for dir in ${pltlist}
  do
    if [ -d ${dir} ]; then

      if [ ! -f ${dir}.processed ] && [ ! -f plotfiles/${dir}.processed ] ; then

        # do processing

        # store the file on HPSS
        ${HTAR} -cvf ${HPSS_DIR}/${dir}.tar ${dir} > ${dir}.htar

	# Ordinarily, we'd check htar's exit status (0 = successful), but 
	# on some machines (like Atlas) htar doesn't return a valid exit
	# status.  Instead we'll grep for the success line at the end of 
	# htar's output (which we piped into a file) and check the output 
	# status of grep
	grep "HTAR: HTAR SUCCESSFUL" ${dir}.htar >> /dev/null

	# $? holds the exit status of the previous command
	if [ $? -eq 0 ]; then
	    
          # mark this file as processed so we skip it next time
          date > ${dir}.processed

	  # output the plotfile name and simulation time to ftime.out
	  if [ -f ${FTIME_EXE} ] ; then
	      ${FTIME_EXE} ${dir} >> ftime.out
	  fi

	  # remove the htar temporary file
	  rm ${dir}.htar

	  # move the plotfile into the plotfiles directory
	  mv ${dir} plotfiles/

	  # the find command will find the plotfiles even in their 
	  # subdirectory, so we need to move the corresponding .processed 
	  # file there too.
	  mv ${dir}.processed plotfiles/

        fi

      fi   # end test of whether plotfile already processed

    fi   # end test of whether plotfile is a directory (as it should be)

  done


  # checkpoint files

  # Take all but the final chk file -- we want to ensure they're completely 
  # written to disk.  Strip out any tar files that are lying around as well 
  # as chkXXXXX.processed files.
  #chklist=$(ls -d ${chk_prefix}* 2>/dev/null | grep -v tar | grep -v processed)
  chklist5=$(find . -type d -name "${chk_prefix}??[05]00" -print | sort)
  chklist6=$(find . -type d -name "${chk_prefix}???[05]00" -print | sort)

  chklist="$chklist5 $chklist6"

  if [ "$chklist" ]; then
    nl=$(echo "$chklist" | wc -l)
    nl=$(expr $nl - 1)
    if [ $nl -eq 0 ]; then
      chklist=""
    else
      chklist=$(echo "$chklist" | head -$nl)
    fi
  fi


  for dir in ${chklist}
  do
    if [ -d ${dir} ]; then

      if [ ! -f ${dir}.processed ]; then

        # store the file on HPSS
        ${HTAR} -cvf ${HPSS_DIR}/${dir}.tar ${dir} > ${dir}.htar

	# Ordinarily, we'd check htar's exit status (0 = successful), but 
	# on some machines (like Atlas) htar doesn't return a valid exit
	# status.  Instead we'll grep for the success line at the end of 
	# htar's output (which we piped into a file) and check the output 
	# status of grep
        grep "HTAR: HTAR SUCCESSFUL" ${dir}.htar >> /dev/null

	# htar's exit status is 0 if it was successful.  The variable $? 
	# holds the exit status of the previous command

	if [ $? -eq 0 ]; then

          # mark this file as processed so we skip it next time
          date > ${dir}.processed

          # remove the htar temporary file
          rm ${dir}.htar

        fi

      fi

    fi
  done

}


#----------------------------------------------------------------------------
# the main function

# archive any diagnostic files first -- give them a unique name, appending
# the date string, to make sure that we don't overwrite anything
datestr=$(date +"%Y%m%d_%H%M_%S")
diag_files=$(find . -name "*_diag.out" -print)

if [ "${diag_files}" ]; then
    ${HTAR} -cvf ${HPSS_DIR}/diag_files_${datestr}.tar ${diag_files} >> /dev/null
fi


# Loop, waiting for plt and chk directories to appear.

while true
do
  process_files
  sleep $N
done
