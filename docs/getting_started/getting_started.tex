

In this chapter we give an overview of \maestro, including some of the
standard problems, how to run the code, some basic runtime parameters,
and how to look at the output.


\section{`Standard' Test Problems}

Different problems in \maestro\ are contained in individual
sub-directories under {\tt MAESTRO/}.  The {\tt GNUmakefile}
in each problem directory lists the components of {\tt MAESTRO}
that are used to build the executable.  Full details of the
{\tt GNUmakefile} can be found in \S~\ref{sec:adding_problems}.

Some of the test problems available are:
\begin{itemize}
\item {\tt flame} \\[-3mm]

The {\tt flame} problem models a planar laminar flame.  Initially cool
fuel and hot ash are put in pressure equilibrium.  Thermal diffusion
transfers heat to the fuel, driving a burning front.  This problem
does not use the traditional \maestro\ elliptic constraint, but
rather enforces $\nabla \cdot U = S$ (through the runtime parameter
{\tt do\_smallscale = T}) as discussed in \cite{SNe}.

\item {\tt spherical\_heat} \\[-3mm]

{\tt spherical\_heat} maps a spherical star (a Chandrasekhar-mass white
dwarf) onto the Cartesian domain and uses an external heat source to
cause the star to expand.  This is the 3D analogue of the {\tt
  test\_basestate} unit test (see \S~\ref{sec:unit_tests}).  This
problem was discussed in \cite{multilevel}.

\item {\tt test2} \\[-3mm]

{\tt test2} places 3 hots spots in a plane-parallel atmosphere.
Burning makes these buoyant bubbles which role up.  This problem was
used in \cite{lowMach3} to compare with compressible solvers.

\item {\tt test\_convect} \\[-3mm]

{\tt test\_convect} drives convection through a plane-parallel
atmosphere using an externally-specified heat source.  This problem
was used to compare with compressible solvers in \cite{lowMach3}
and to test the multilevel algorithm in \cite{multilevel}.

\item {\tt test\_spherical} \\[-3mm]

{\tt test\_spherical} sets up an isentropically stratified star
and stirs it up with a random velocity field.  The low Mach number
constraint is replaced with the anelastic constraint (through
the {\tt beta\_type} runtime parameter).  Analytically, under
these conditions, the density of the star should not change.
This test problem was discussed in \cite{lowMach4}.

\end{itemize}


\section{Compiling and Running}

To build the \maestro\ executable, simply type `{\tt make}' in the
problem directory.  The executable will have a name like {\tt
  main.Linux.Intel.exe}, where the specific parts of the name depend
on the compilers and OS used.  \maestro\ can be built with support for
parallelism (using MPI or MPI+OpenMP), or compiled as a serial code.
The top portion of the {\tt GNUmakefile} can be edited to choose the
build options.  Setting {\tt MPI := t} will build the code to use MPI
for parallelization.  Setting {\tt OMP := t} will use OpenMP.  OpenMP
is used together with MPI, with MPI distributing the grids across the
processors and within a shared-memory node, OpenMP allows many cores
to operate on the same grid.  A final build option determines whether
to build the code with support for debugging.  Setting {\tt NDEBUG :=
  t} disables debugging features.

If the {\tt helmeos} equation of state is chosen for the problem, then
the data table for the equation of state, {\tt
  extern/EOS/helmeos/helm\_table.dat} needs to be copied to the
directory in which the code is run.

Each problem will have one or more inputs files (for example, {\tt
  test2/inputs\_2d}) which override the default values for one or more
runtime parameters.  The code is run simply as:
\begin{verbatim}
  ./main.Linux.Intel.exe inputs_2d
\end{verbatim}
for a serial executable, and, depending on your MPI environment, something like:
\begin{verbatim}
  mpiexec -n 16 ./main.Linux.Intel.mpi.exe inputs_2d
\end{verbatim}
for the parallel code.

As the code runs, it will output both plotfiles and checkpoints as
well as one of more text diagnostic files (like {\tt
  maestro\_diag.out}) with integral or extrema information (like
maximum Mach number) from each timestep.  By default, the plotfiles
will be named {\tt plt}{\em nnnnn}, where the number {\em nnnnn} is
the timestep number when the file was outputted.  Similarly, the
checkpoints are named {\tt chk}{\em nnnnn}.  BoxLib plotfiles and
checkpoints are actually directories, with the data stored in
sub-directories grouped by refinement level.  Details of the simulation
(build information, number of processors used, output date, output
directory, runtime parameter values, ...) are stored in the {\tt
  job\_info} file in each plotfile directory.

A large number of runtime parameters affect the code's behavior.  Any
runtime parameter can be set either in the inputs file, as {\tt parameter
  = value}, or on the command line by adding {\tt --parameter value} after
listing the inputs file on the command line.  A full list of runtime
parameters is detailed in \S~\ref{sec:runtime_parameters}.  Below we
outline the most common runtime parameters.


\section{Common Runtime Parameters}

\subsection{Controlling Timestepping and Output}

Parameters that set the maximum time for the simulation to run
include:
\begin{itemize}
\item {\tt stop\_time} is the maximum simulation time, in seconds,
      to evolve the system for.

\item {\tt max\_step} is the maximum number of steps to take.
\end{itemize}

\noindent Parameters affecting the size of the timestep include:
\begin{itemize}
\item {\tt cflfac} is a multiplicative factor ({\tt $\le 1$}) 
      applied to the advective CFL timestep

\item {\tt init\_shrink} is the factor ({\tt $\le 1$}) by which to reduce 
      the initial timestep from the estimated first timestep.
\end{itemize}

\noindent Parameters affecting output and restart include:
\begin{itemize}

\item {\tt restart} tells \maestro\ to restart from a checkpoint.  The
      value of this parameter should be the file number to restart from.
      For example, to restart from the checkpoint file {\tt chk00010},
      you would set {\tt restart = 10}.

\item {\tt plot\_int} is the number of steps to take between
  outputting a plotfile

\item {\tt plot\_deltat} is the simulation time to evolve between
  outputting a plotfile.  Note: to output only based on simulation
  time, set {\tt plot\_int = -1}.

\item {\tt check\_int} is the number of steps to take between
  outputting a checkpoint.

\end{itemize}

\subsection{Defining the Grid and Boundary Conditions}

Parameters that determine the spatial extent of the grid, 
the types of boundaries, and the number of computational cells include:
\begin{itemize}

\item {\tt max\_levs } is the maximum number of grid levels in the AMR
  hierarchy to use.  {\tt max\_levs = 1} indicates running with only a
  single level spanning the whole domain.

\item {\tt n\_cellx }, {\tt n\_celly }, {\tt n\_cellz } the size of
  base level in terms of number of cells, in the $x$, $y$, and $z$
  coordinate directions.

\item {\tt max\_grid\_size } the maximum extend of a grid, in any
  coordinate direction, as measured in terms of number of cells.

  For multilevel problems, the parameter {\tt max\_grid\_size\_1}
  controls the maximum extent on level 1 (the base grid), {\tt
    max\_grid\_size\_2} controls the maximum extent on level 2, and
  {\tt max\_grid\_size\_3} controls the maximum extent on levels 3 and
  higher.

\item {\tt prob\_lo\_x }, {\tt prob\_lo\_y }, {\tt prob\_lo\_z } is
  the physical coordinate of the lower extent of the domain boundary
  in the $x$, $y$, and $z$ coordinate directions.

\item {\tt prob\_hi\_x }, {\tt prob\_hi\_y }, {\tt prob\_hi\_z } is
  the physical coordinate of the upper extent of the domain boundary
  in the $x$, $y$, and $z$ coordinate directions.

\item {\tt bcx\_lo }, {\tt bcy\_lo }, {\tt bcz\_lo }, 
      {\tt bcx\_hi }, {\tt bcy\_hi }, {\tt bcz\_hi } are the boundary
   condition types at the lower (`{\tt lo}') and upper (`{\tt hi}')
   domain boundaries in the $x$, $y$, and $z$ coordinate directions.
   The different types are set via integer flags listed in table~\ref{arch:table:bcflags}.

   \begin{table}[h]
   \caption{\label{arch:table:bcflags} Boundary condition flags}  
   \begin{center}
   \begin{tabular}{ll}
   \hline
   BC type    & integer flag \\
   \hline
   periodic             & $-1$ \\
   inlet (user-defined) & $11$ \\
   outlet               & $12$ \\
   symmetry             & $13$ \\
   slip wall            & $14$ \\
   no-slip wall         & $15$ \\
   \hline
   \end{tabular}
   \end{center}
   \end{table}

\end{itemize}

Note that grid cells must be square, i.e. $\Delta x = \Delta y = \Delta z$
where $\Delta x$ on the base grid is computed as $({\tt prob\_hi\_x}
- {\tt prob\_lo\_x})/{\tt n\_cellx}$.  For multilevel problems, the effective
number of zones on the finest grid in the $x$ direction will be
${\tt n\_cellx} \cdot 2^{({\tt max\_levels} -1)}$.



\section{Working with the Output}

Visualization and analysis are done with on the plotfiles.  A
number of in-house and externally developed tools can work 
with BoxLib-formatted plotfiles.


\subsection{\tt Amrvis}

{\tt Amrvis} is an easy-to-use visualization tool developed at LBL for
2- and 3D datasets which can plot slices through 3D datasets as well
as volume-renderings.  It can also very easily extract 1D lines
through the dataset along any coordinate direction.  It is distributed
separately from the \maestro\ distribution.


\subsection{{\tt data\_processing} scripts}

Several useful analysis scripts (written in Fortran 90) can be found
in {\tt fParallel/data\_processing}.  The {\tt GNUmakefile} there
needs to be edited to indicate which of the tools to build.  For
example, to extract the density along a line from the center of a
plotfile, {\tt plt00200}, in the $y$-direction:

\begin{verbatim}
fextract.Linux.gfortran.exe -d 2 -v "density" -p plt00200
\end{verbatim}

These routines are described in \S~\ref{sec:analysis}.




\subsection{VisIt}

VisIt is a powerful, DOE-supported visualization tool for 2- and 3D
datasets.  It can do contouring, volume rendering, streamlines, ...\
directly from BoxLib plotfiles (to open a plotfile in VisIt, point to
the {\tt Header} file inside the plotfile directory).  Details on
visit can be found at {\tt https://wci.llnl.gov/codes/visit/home.html}\,.

\subsection{Diagnostic Files}

By default, \maestro\ outputs global diagnostics each timestep into a file
called {\tt maestro\_diag.out}.  This includes the maximum Mach number,
peak temperature, and peak nuclear energy generation rate.  Individual problems
can provide their own {\tt diag.f90} file to produce custom diagnostic
output.

