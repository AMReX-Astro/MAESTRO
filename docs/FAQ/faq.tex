\section{Compiling}

\begin{enumerate}

\item {\em Does it matter if we use a Fortran 90 compiler instead of a 
   Fortran 95 compiler?}


   On some machines it does---Fortran 95 specifies that any local
   allocated arrays are automatically deallocated when a subroutine
   ends.  Fortran 90 does not do this.  Most MAESTRO routines rely 
   on this Fortran 95 feature.  

   On IBM machines, for instance, using {\tt xlf90} instead of {\tt
     xlf95} for MAESTRO will produce memory leaks.

  

\end{enumerate}

\section{Running}

\begin{enumerate}

\item {\em  How do we turn off all the initial projections to look at the
   initial velocity field as specified in initdata, instead of as
   modified by the velocity constraint?} 
%
\begin{verbatim}
    max_step  = 1
    init_iter = 0
    init_divu_iter = 0
    do_initial_projection = F
\end{verbatim}



\item {\em How can I obtain profiling infomation for my run?}

  The code is already instrumented with timers.  Simply compile with
  {\tt PROF=TRUE} in the {\tt GNUmakefile}, or equvalently do 
  {\tt make PROF=t}.  A file containing a summary of the timings will
  be output in the run directory.

  An alternate way to get single-processor timings, when using 
  the GCC compilers is to add {\tt -pg} to the compilation flags
  for both {\tt gfortran} and {\tt gcc}.  Upon completion, a
  file names {\tt gmon.out} will be produced.  This can be 
  processed by {\tt gprof} running 

  {\tt~~~ gprof} {\em exec-name}
  
  where {\em exec-name} is the name of the executable.

\end{enumerate}




\section{I/O}

\begin{enumerate}

\item {\em How can we dump out a variable to a plotfile from any point in the
   code?} 
%
\begin{verbatim}
    use fabio_module

    call fabio_ml_multifab_write_d(uold,mla%mba%rr(:,1),"a_uold")
    call fabio_ml_multifab_write_d(umac(:,1),mla%mba%rr(:,1),"a_umacx")
\end{verbatim}



\item {\em How can I tell from a plotfile what runtime parameters were
   used for its run? or when it was created?}

   In each plotfile directory, there is a file called {\tt job\_info}
   (e.g.\ {\tt plt00000/job\_info}) that lists the build directory and
   date, as well as the value of every runtime parameter for the run.


\item {\em How can I force the code to output a plotfile at the next
   step?}

   In the output directory (where the code is running) do `{\tt touch
     .dump\_plotfile}'.  This will create an empty file called {\tt
     .dump\_plotfile}.  At the end of each step, if the code finds
   that file, it will output a plotfile.  Simply delete the file to
   restore the code to its normal plotfile behavior.

\end{enumerate}



\section{Algorithm}

\begin{enumerate}

\item {\em In the final projection in the algorithm, we project
  $U^{n+1}$, using a time-centered $\beta_0$, a time-centered $\rho_0$, but
  an ``$n+1$''-centered $S$.  Why then is the resulting $\phi$ (which then
  defines $\pi$) is at ``$n+1/2$''?}

  The short answer to this question is that you should think of this
  as really projecting  $(U^{n+1} - U^n)$ and the right hand side as having
  $(S^{n+1} - S^n)$.  This is because the pressure enters the dynamic equations as
  $(U^{n+1} - U^n) = \ldots + \frac{1}{\rho^{n+1/2}} \nabla \pi^{n+1/2}$.
  (We approximate $\pi^{n+1/2}$ by $\pi^{n-1/2}$ then do the projection to fix the
  $\pi$ as well as the $U$.)

  So everything is in fact time-centered.

\end{enumerate}
