Here, we list notes on problems with specific compilers and \maestro.


%-----------------------------------------------------------------------------
\section{Cray}

\begin{itemize}
\item Cray 8.0.2 compiles and runs \maestro\ fine on the interlagos/jaguarpf 
machine at OCLF.
\item Cray 8.0.7 compiles and runs \maestro\ fine on hopper (8/21/12).
\end{itemize}


%-----------------------------------------------------------------------------
\section{gfortran}

Probably the best compilers for \maestro.  
Some notes:
\begin{itemize}
\item gfortran 4.4.3 dies with an out of bounds error in multigrid for
2+ level runs with effective 128$^3$ resolution or better.
\item gfortran 4.5 has no known issues.
\item gfortran 4.6.1--4.6.3 on Fedora (15 and 16) have a bug that 
shows up in multi-processor, multilevel runs ({\tt toy\_convect} on 4
processors, with {\tt inputs\_2d\_ml.test} for instance).  The symptom
is a crash during initialization with the message that ``message sizes
do not match across processes in the collective'' in a {\tt
parallel\_bcast} call.  This is in {\tt cluster\_f.f90}, and the issue
seems to be a multiplication error in computing the size to allocate
{\tt bxs}.  The bug is not present when you compile in debug mode, so
it seems to be related to optimization.
\item gfortran 4.7.1 (prerelease) seems to have fixed the above issue,
but now wdconvect with 2-level, effective 768$^3$ dies due to an
unknown seg fault at the beginning of the run.
\end{itemize}

An added benefit of the gfortran compilers is that their debugging
features are very reliable.


%-----------------------------------------------------------------------------
\section{IBM (xl* compilers)}

Recent versions of these compilers seem to work ok.  Some notes:
\begin{itemize}
\item You need to use {\tt xlf95}, not {\tt xlf90} to compile, since
  MAESTRO relies on the Fortran 95 feature that arrays are
  automatically deallocated when you leave a subroutine.

\item Many (all?) IBM machines have a different endian-ness than
  Intel-like chips.  \boxlib\ plotfiles store information used to
  dechipher the endian-ness of the data.  To do this properly on
  the IBM machines, you need to set the preprocessor flag {\tt BL\_AIX},
  which is interpretted by {\tt fabio\_c.c}.  This can be done for the
  IBM compilers by adding {\tt -Wp,-DBL\_AIX} to the {\tt CFLAGS} variable.

\end{itemize}

%-----------------------------------------------------------------------------
\section{Intel}

Overall, these tend to be flaky. 

Machine specific notes:

\begin{itemize}
\item on Hopper, with OpenMP:

From NERSC support ``Intel OpenMP has an extra thread at run time
beyond OpenMP threads. Â This messes up the default affinity settings
for aprun, since you have a spare thread waiting until all the other
ones are completed.  You need to break the default affinity by adding
either one of these arguments to aprun:''

{\tt -cc none} or {\tt -cc numa\_node}.
\end{itemize}

%-----------------------------------------------------------------------------
\section{PathScale}

These are the prefered compilers on jaguar, however, the PathScale
compilers are no longer actively supported on the Crays and therefore
should be considered depricated. 


\ \\
Machine specific notes:
\begin{itemize}

\item  To run with BDS, change {\tt -Ofast} to {\tt -O2} in {\tt Linux\_pathscale.mak}

\item (on jaguar) with OpenMP, the Pathscale compiler warns about
  variables that are shared, but doesn't always give useful line
  numbers.  In debug mode, add ``-fullwarn'' to the compilation to get
  the compiler output to tell you where the problems are. 


\end{itemize}


%-----------------------------------------------------------------------------
\section{PGI}

The general feeling with these compilers is that they produce slower
code than the PathScale compilers.

\ \\
Machine-specific notes:
\begin{itemize}

\item (on Kraken) The bounds checking routines do not like the way some of
the arrays are allocated and flag them as errors.  For instance, in
{\tt layout.f90}, we allocate a box as:
\begin{verbatim}
    type(box) :: bxs(3**get_dim(b))
\end{verbatim}
but the bounds checking routine seems to fail on this.

\item (on hopper) There are problems with code compiled with {\tt -fast}
instead of just {\tt -O}.  gcc/gfortran seem to work better and 
are only slighly slower.
\end{itemize}


