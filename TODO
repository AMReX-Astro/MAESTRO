-- figure out what density_cutoff should be in initdata.f90 (in relation
   to anelastic_cutoff), and understand what values of this give a valid
   basestate expansion.

-- in modify_scal_force, for spherical, why don't we compute divu for
   the base state in the radial geom and then put it on the Cart grid,
   instead of putting w0 onto the Cart grid first and then computing
   div{U + w_0} together?  This is more along the lines of how we
   treat the div{w_0} stuff in update_vel.f90

-- should we be computing beta_0 differently for spherical?  In 
   particular, should we do linear reconstruction on g?

-- the small scale problem should read in its initial model in our
   standard format

-- are we handling the thermodynamics consistently when we hit small_temp?

-- only need to keep one set of species names around in a network

-- need to add entropy to the gamma_law_general EOS

-- merge flame and flame_1d

-- In Maestro, initialize.f90, we have:
 
     ! check for proper nesting
     if (.not. ml_boxarray_properly_nested(mla%mba, 3, pmask)) then
        call bl_error('restart_grids not properly nested')
     end if
 
   the '3' is ng_s.  For ppm_type = 2, should this be 4?

-- add the ability in _parameters to check to make sure that runtime
   parameters are valid (e.g. cflfac should be <= 1).

-- sync the Coulomb corrections bust check in helmeos up with the main
   version (i.e. check etot and stot as well).

-- in make_div_coeff.f90, if a refined level does not include the 
   anelastic cutoff, then the code that enforces the cutoff:

    ! Redo the anelastic cutoff part
    do r=anelastic_cutoff_coord(i),nr(i)
       div_coeff(i,r) = div_coeff(i,r-1) * (rho0(i,r)/rho0(i,r-1))
    end do

   is not defined (it will try to do a 0/0)

   To fix this, we need to have a check here that the data is valid
   above the anelastic cutoff, and otherwise, skip this.  Perhaps this
   means that we need to use numdisjointchunks() and r_start_coord and
   r_end_coord.

-- add profiles to diag.f90 -- for instance, Delta T', Delta rho' vs. r.
   dump out every ~100 timesteps.

-- switch ignition_chamulak over to using a burner_aux module instead of
   common blocks for passing stuff into the RHS.


-- gamma_law_general should be OpenMP-ed


-- burner optimization.  For problems where reactions dominate the runtime,
   we should only burn on the finest zones (look at the mask), and restrict
   down the energy release otherwise.  We will still have to call the EOS
   to get the updated temperature, but this can save ~20% in 2-d.


-- EOS: remove the eos data in the eos_stuff module that is just
   declared to allow us to pass data into/outof the EOS.
   
   instead define a new data type:

      type(eos_data) :: eos_stuff

      ...

      eos_stuff%dens = s(i,j,k,rho_comp)
      eos_stuff%temp = s(i,j,k,temp_comp)

      call eos(eos_input_rt, eos_stuff)

      h = eos_stuff%enthalpy

   
   This would make the threadsafe-ness easier, since we make eos_stuff
   private in the calling function instead of creating a common block 
   in the eos module and making that private.

   This also means that we don't have to worry about remembering the
   ordering of the arguments in the EOS call.

   NOTE: this will affect CASTRO as well.

